#include <stdio.h>
#include <stdbool.h> // работа с типом данных true/false
#define MAX_SIZE 100 // максимальный размер стека
typedef struct { // определяет новую структуру данных Stack
    int items[MAX_SIZE]; // массив с заданным кол-вом элементов
    int top; // индекс верхнего элемента стека
} Stack;
void initStack(Stack *s) { // инициализация стека
// *s - указатель для работы с оригинальным стеком
    s->top = -1; // присваивание, означает, что стек пуст
}
int isStackState(Stack *s) {
// возвращает -1, если стек имеет элементы, true, если пуст, false, если полон
    if (s->top == -1) return true; // стек пуст
    if (s->top == MAX_SIZE - 1) return false; // стек полон
// MAX_SIZE - 1 - индекс последнего элемента в массиве
    return -1; // Стек имеет элементы
}
bool push(Stack *s, int value) { // добавление элемента в стек
    if (!isStackState(s)) { // Проверяем, полон ли стек
        printf("Стек полон. Невозможно добавить элемент %d.\n", value);
// value — это значение, которое мы пытаемся добавить в стек
        return false;
    }
    s->items[++(s->top)] = value; // добавляем элемент в стек
// увеличиваем значение top на 1, указывая на след элемент
// присваиваем значение переменной value этому индексу
// таким образом происходит добавление
    return true;
}
int pop(Stack *s) { // удаление элемента из стека
    if (isStackState(s) == true) { // проверяем, пуст ли стек
        printf("Стек пуст. Невозможно удалить элемент.\n");
        return -1; // можно использовать другое значение для обозначения ошибки
    }
    return s->items[(s->top)--]; // возвращаем верхний элемент и уменьшаем top
// обращается к массиву items по индексу, который был ранее задан значением top
// сначала получаем значение top, затем уменьшаем его на 1
// получаем текущий верхний элемент стека, а затем уменьшаем индекс верхнего элемента
} 
int peek(Stack *s) { // получение верхнего элемента стека без удаления
    if (isStackState(s) == true) { // проверяем, пуст ли стек
        printf("Стек пуст. Невозможно получить верхний элемент.\n");
        return -1; // или другое значение для обозначения ошибки
    }
    return s->items[s->top]; // возвращаем верхний элемент
}
int main() {
    Stack stack; // объявляет переменную stack типа Stack
    initStack(&stack); // инициализирует стек, передавая адрес переменной stack
    push(&stack, 40); // добавление элемента стека
    push(&stack, 70);
    printf("Верхний элемент: %d\n", peek(&stack));
    printf("Удаленный элемент: %d\n", pop(&stack));
    printf("Удаленный элемент: %d\n", pop(&stack));
    pop(&stack); // попытка удалить из пустого стека
    return 0;
}
