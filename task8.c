#include <stdio.h> // ввод-вывод
#include <stdlib.h> // ф-и общего назначения
#include <string.h> // работа со строками
#include <ctype.h> // работа с символами

#define MAX 100 // максимальный размер стека

char stack[MAX]; // инициализация стека
int top = -1;
// инициализация переменной, указывающей на верхний элемент стека
// -1 означет, что стек пуст

int is_empty() { // проверка, пуст ли стек
    return top == -1;
// возвращает 1, если пуст, иначе 0
}

void push(char c) { // добавление элемента
// принимает один параметр
    if (top < MAX - 1) { // если стек не полон, то...
        stack[++top] = c;
// сначала переходим на один элемент наверх
// только потом добавляем элемент
    }
}

char pop() { // извлечение элемента из стека
    if (!is_empty()) { // если стек не пуст, то...
        return stack[top--]; // возвращаем верхний элемент и уменьшаем top
    }
    return '\0'; // иначе возвращаем пустой элемент
}

char peek() { // просмотр элемента стека
    if (!is_empty()) { // если стек не пуст, то...
        return stack[top]; // возвращаем верхний элемент, не удаляя его
    }
    return '\0'; // иначе пустой элемент
}

int precedence(char op) {
// принимает символ, возвращает число
    switch (op) { // оператор выбора
        case '+':
        case '-':
            return 1;
        case '*':
        case '/':
            return 2;
        default:
            return 0;
// оператор имеет нулевой приоритет
// или не является допустимым оператором
    }
}

void infix_to_postfix(const char *infix, char *postfix) {
// const char *infix - указатель на строку, значение которой не будет изменяться
// char *postfix - указатель на строку, в которую будет записано постфиксное выражение
    int i = 0, j = 0; // итерация по infix и postfix
    while (infix[i]) { // пока не достигнут конец строки infix
        if (isdigit(infix[i])) { // если символ цифра, то...
            while (isdigit(infix[i])) { // обработка многозначных чисел
// продолжается до тех пор, пока текущий символ является цифрой
                postfix[j++] = infix[i++]; 
// копирует текущий символ из строки infix в строку postfix и увеличивает оба индекса
// (j для постфикса и i для инфикса), это позволяет добавлять все цифры многозначного числа
            }
            postfix[j++] = ' '; // добавляем пробел между числами
        } else if (infix[i] == '(') { // добавление скобки в стек, переход к след элементу
            push(infix[i]); 
            i++;
        } else if (infix[i] == ')') {
// извлекаем элементы из стека и добавляем их в постфиксное выражение
// до тех пор, пока не встретим открывающую скобку
            while (!is_empty() && peek() != '(') {
                postfix[j++] = pop();
                postfix[j++] = ' ';
            }
            pop(); // извлекаем '(' из стека
            i++;
        } else {
            while (!is_empty() && precedence(peek()) >= precedence(infix[i])) {
// пока стек не пуст и приоритет верхнего элемента стека
// больше или равен приоритету текущего оператора
                postfix[j++] = pop();
// извлекает верхний элемент из стека и добавляет его в строку postfix
                postfix[j++] = ' ';
// добавляет пробел после извлеченного оператора
// для разделения операторов в постфиксном выражении
            }
            push(infix[i]); // добавляет текущий оператор в стек
            i++; // переход к следующему символу
        }
    }

    while (!is_empty()) {
// извлекает оставшиеся элементы из стека
// и добавляет их в строку postfix, пока стек не станет пустым
        postfix[j++] = pop();
        postfix[j++] = ' ';
    }
    postfix[j] = '\0'; // нулевой терминатор для обозначения конца строки
}

int main() {
    FILE *file; // указатель открываемого файла
    char infix[MAX], postfix[MAX]; 
    char results[MAX * 10]; // массив для хранения всех результатов постфиксных выражений

    file = fopen("expressions.txt", "r"); // открытие файла на чтение

    if (!file) { 
        perror("Ошибка открытия файла");
        return EXIT_FAILURE;
    }

    results[0] = '\0'; // инициализируем строку результатов

    while (fgets(infix, MAX, file)) { 
        infix[strcspn(infix, "\n")] = 0; // удаляем символ новой строки

        infix_to_postfix(infix, postfix); // преобразование инфиксного в постфиксное

        strcat(results, postfix); // добавляем результат в массив результатов
        strcat(results, "\n");     // добавляем новую строку для разделения выражений
        
        top = -1; // сбрасываем значение для обработки нового выражения
    }

    fclose(file); 

    file = fopen("expressions.txt", "a"); // открытие файла на добавление результатов

    if (!file) { 
        perror("Ошибка открытия файла");
        return EXIT_FAILURE;
    }

    fprintf(file, "%s", results); // записываем все результаты в файл

    fclose(file);
    
    return EXIT_SUCCESS; // успешное завершение программы
}
